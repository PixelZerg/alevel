---
title: 1.6 - OOP Concepts
---

## Terms

- Method = code or routines _(contained within a class)_
- information hiding = methods/props can only be accessed by certain classes
- Class = definition of the properties and methods _(of a group of similar objects)_
- Object = created from class; instance.
- property = class member for holding data
- inheritance = concept that properties and methods in one class can be shared with subclass.
- instantiation = creating an object from a class
- polymorphism = Methods overriden such that they are able to operate on differing underlying types of data.
- abstract data type = cannot be instantiated but can be inherited

## Concepts
- Modular design = breaks system into smaller units (modules)
  - advantages:
    - easy to amend: only affected module needs editing
    - easy add new functionality: new module
    - management: programmers can work independently on self-contained modules
    - objects inherit behaviors+attributes = reuse code = good
    - help avoid changes made to code producing inadvertant side-affects in other areas
    - libraries can be created: code reused easily
    - avoids side effects = values being altered/things being changed in other parts of the program
- Encapsulation = putting properties, methods and data in one object (data and code same object).
  - self-contained = reduce side affects/implications
- Side effects undesirable because:
  - debugging program is harder
    - whole program may need to be analysed as opp to just certain subroutines
  - independence of subroutine reduced
  - reusability is reduced because may be more difficult to use in a different program
- polymorphism = the ability to present the same interface for differing underlying forms (data types).
  - E.g: most languages, integers and floats are polymorphic - can add, subtract, etc regardless if types different.
- recursion
  - recursion = when something consists of or is defined in terms of itself
  - circular definition avoided by defining a **base case** - so that the definition doesn't halt upon execution (need a starting point)
  - Pattern followed by recursive functions/procedures:
    - if base case, return the computationally easy solution (if a function) and stop recursing.
    - Otherwise (**general case**), try moving towards the base case
  - stack (and stack overflow)
    - local variables, etc may be associated with functions/procedures. These variables have no existence outside its functions/procedures.
    - every such local variable, etc are allocated space in area of main memory called a **stack**
    - Space allocated to each new set of variables = **stack frame**. Stack frame holds things such as:
      - function's parameters
      - return address (address to return to after method executed)
      - contents of registers at diff stages in the execution of program (so that they may be restored after method execution). Method can also write to these registers while executing.
    - many recursive calls will mean many stack frames are needed
    - there is a limit of amount of main memory set aside as stack
    - When stack space is run out of ( very possible during recursion), it is called a **stack overflow**.

## Good Program Design

- cohesive = strong interconnection between elements within a moudle
  - highly interrelated parts of the real-world problem should be in the same **software system**.
  - broken down into modules which
    - are highly independent
    - accomplish a single objective
  - functional cohesion
    - modules contain only one function or one logically-related task
    - every element essential to the task
    - advantages:
      - module can easily be replaced by other serving same purpose
        - because work done is localised (no side-effects)
      - If program fails:
        - easier to locate error (know it is in that module)
        - easier to debug
      - units independent = can be worked on individually by different developers
- loosely coupled = relationships between modules is loose
  - want to make modules as independent as possible
  - lower the coupling, the less likely that other modules need to be considered during:
    - module creation
    - understanding module
    - debugging a module
    - change a given module
  - how:
    - subroutines or modules only allowed to access data they need to perform their assigned task
    - data transfer between modules visible (in the module parameters)
      - no hidden flows of data (via global variables or shared data areas, for example)
    - No control information passing between modules (e.g boolean flags)
    - number of module parameters to be kept to a minimum

## Programming Paradigms

- Object Oriented Programming = all aspects of a software system or subsystem represented as a collection of interacting objects, with the goal of modelling (sth)
  - Object = data + operations that act on the data
  - **objects share behavior but not state**
    - share code but not attribute values, etc
    - code itself not copied
  - Encapsulating and information hiding (wrt Class)
    - concept of black box. Inputs and Outputs but process inside (**behaviour**) not need to be known.
    - Which features should be known outside and which private = **visibility**
    - Parts exposed = **interface**
      - should reveal as little as needed about inner-workings of the class
    - helps enforce modularity
  - Inheritance
    - allows a class to be derived from an existing class wihtout needing to modify the existing class itself
    - derived class = have all attributes and methods of parent class, but new ones can be added
      - aka subclass
      - aka descendent class
    - Inheritance between classes is a **"is-a"** relationship.
    - Purpose
      - simplify writing code
      - helps avoid need to repeat common operation code and attributes in multiple classes by centralising them within a base class
  - Polymorphism
    - giving an action a name that is shared throughout an object heirarchy, with each object in the heirarchy implementing the action in a way approriate to itself.
  - Aggregation
    - (Not unique to OOP)
    - when an object owns another object
    - slave object is destroyed if owner object is destroyed.
      - destructor
  - Composition
    - Association between objects
    - slave object is not destroyed when owner object destroyed